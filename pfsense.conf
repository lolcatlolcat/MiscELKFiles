input {
  udp {
    type => "pfsense"
    port => 5514
	}
}
filter {
	if [type] == "pfsense" {
		grok {
      match => [ "message", "<(?<evtid>.*)>(?<datetime>(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]) (?:2[0123]|[01]?[0-9]):(?:[0-5][0-9]):(?:[0-5][0-9])) (?<prog>.*?): (?<msg>.*)" ]
    }
    mutate {
      gsub => ["datetime","  "," "]
    }
    date {
      match => [ "datetime", "MMM dd HH:mm:ss" ]
      timezone => "America/New_York"
    }
    mutate {
      replace => [ "message", "%{msg}" ]
    }
    mutate {
      remove_field => [ "msg", "datetime" ]
    }
}
if [prog] =~ /^dhcpd/ {
  if [message] =~ /^DHCPREQUEST/ {
    grok {
      match => ["message", "%{WORD:dhcp_action} for %{IPV4:src_ip} from %{MAC:src_mac} \(%{WORD:req_host}\) via %{WORD:fw_int}: %{GREEDYDATA:dhcp_info}",
        "message", "%{WORD:dhcp_action} for %{IPV4:src_ip} from %{MAC:src_mac} via %{WORD:fw_int}: %{GREEDYDATA:dhcp_info}",
        "message", "%{WORD:dhcp_action} for %{IPV4:src_ip} from %{MAC:src_mac} via %{WORD:fw_int}" ]
    }
   }
  if [message] =~ /^DHCPNAK/ {
    grok {
      match => [ "message", "%{WORD:dhcp_action} on %{IPV4:requested_ip} to %{MAC:src_mac} via %{WORD:fw_int}"]
    }
  }
  if [message] =~ /^DHCPACK/ {
    grok {
      match => ["message", "%{WORD:dhcp_action} on %{IPV4:requested_ip} to %{MAC:src_mac} \(%{DATA:dest_host}\) via %{WORD:fw_int}"]
    }
  }
}
if [prog] =~ /^barnyard/{
	drop{ }
	}
if [prog] =~ /^snort/{
	grok {
		patterns_dir => "/etc/logstash/conf.d/patterns"
		match => [ "message", "\[%{INT:snort_gid}:%{INT:snort_sid}:%{INT:snort_rev}\] %{DATA:alert} \[%{DATA:classtype}\] \[%{DATA:snort_priority}\] \{%{DATA:proto}\} %{IPV4:src_ip}:%{INT:src_port} -> %{IPV4:dest_ip}:%{INT:dest_port}" ]
		}
  if [snort_sid] >= 2000000 and [snort_sid] < 3000000 {
      mutate {
        add_field => ["ET_lookup","http://doc.emergingthreats.net/%{snort_sid}"]
      }
  }
  if [snort_sid] >= 1000000 {
    mutate {
      add_field => ["SID_lookup", "https://www.snort.org/search?query=%{snort_sid}"]
      convert => { "SID_lookup" => "url" }
    }
  }
  if [src_ip] !~ /^169.254\./ or /^10\./ or /^192.168\./ or /^172.16\./ {
    mutate {
      add_field => ["Senderbase_lookup","http://www.senderbase.org/lookup/?search_string=%{src_ip}" ] 
      add_field => ["Spamhaus_lookup", "http://www.spamhaus.org/query/bl?ip=%{src_ip}" ]
      }
    dns {
      reverse => [ "src_ip", "dest_ip"]
      action => "replace"
    }
    geoip {
      source => "src_ip"
      target => "geoip"
    }
  }
} 
if [prog] =~ /^filterlog$/ {  
    mutate {
      remove_field => [ "msg", "datetime" ]
    }
    grok {
      patterns_dir => "/etc/logstash/conf.d/patterns"
      match => [ "message", "%{PFSENSE_LOG_DATA}%{PFSENSE_IP_SPECIFIC_DATA}%{PFSENSE_IP_DATA}%{PFSENSE_PROTOCOL_DATA}",
                 "message", "%{PFSENSE_LOG_DATA}%{PFSENSE_IPv4_SPECIFIC_DATA_ECN}%{PFSENSE_IP_DATA}%{PFSENSE_PROTOCOL_DATA}",
                 "message", "%{PFSENSE_LOG_DATA}%{PFSENSE_IPv6_SPECIFIC_DATA}"]
    }
    mutate {
      lowercase => [ 'proto' ]
    }
    geoip {
      source => "src_ip"
      target => "geoip"
    }
## Drop APIPA
   if [src_ip] =~ /^169.254\./ {
	drop { }
	}
## Add some IP reputation lookups
   mutate {
	add_field => ["Senderbase_lookup","http://www.senderbase.org/lookup/?search_string=%{src_ip}" ] 
	add_field => ["Spamhaus_lookup", "http://www.spamhaus.org/query/bl?ip=%{src_ip}" ]
	}
## Do some DNS lookups
  dns {
 	reverse => [ "src_ip", "dest_ip"]
  action => "replace"
  }
## Remove message field from Kibana. We got all the data out of it
	mutate {
		remove_field => "message"
		remove_tag => "_geoip_lookup_failure"
	 }
 }
output {
if [type] == "pfsense"{
 elasticsearch {
	hosts => ["ELK:9200"]
	index => "pfsense-%{+YYYY.MM.dd}"
  }
 }
}
